+++
title = "This Month in Rune"
date = 2020-10-01
draft = true
template = "post.html"

[taxonomies]
categories = ["TMIR"]
tags = ["updates"]

[extra]
author = "John-John Tedro"
+++

Less then one month ago [I announced Rune on
Reddit](https://www.reddit.com/r/rust/comments/in67d3/introducing_rune_a_new_stackbased_dynamic/).
And the response has been amazing.

In this post I'll detail the developments that have happened in the Language
since its initial announcement.

<!-- more -->

## Macros

We taught Rune how to parse and execute macros. Macros are procedures which
takes a token stream, and produces another one. Like procedural macros in Rust.

Macros in Rune are currently experimental. They can only be defined as part of a
native module and needs a compiler option to enable.

Rune parsing has been designed in a way so that it can be used in macros,
similarly to what you get through the `syn` crate. And we also provide a
`quote!` Rust macro to perform quasi-quoting.

The following is an example macro that comes with the `std::experiments` crate,
that performs "stringy math":

```rust
use rune::ast;
use rune::Resolve as _;
use rune::{quote, MacroContext, Parser, Spanned, TokenStream};

/// Implementation for the `stringy_math!` macro.
pub(crate) fn stringy_math(
    ctx: &mut MacroContext,
    stream: &TokenStream,
) -> runestick::Result<TokenStream> {
    let mut parser = Parser::from_token_stream(stream);

    let mut output = quote!(ctx => 0);

    while !parser.is_eof()? {
        let op = parser.parse::<ast::Ident>()?;
        let arg = parser.parse::<ast::Expr>()?;

        output = match op.macro_resolve(ctx)?.as_ref() {
            "add" => quote!(ctx => (#output) + #arg),
            "sub" => quote!(ctx => (#output) - #arg),
            "div" => quote!(ctx => (#output) / #arg),
            "mul" => quote!(ctx => (#output) * #arg),
            _ => {
                return Err(From::from(runestick::SpannedError::msg(
                    op.span(),
                    "unsupported operation",
                )));
            }
        }
    }

    parser.parse_eof()?;
    Ok(output)
}
```

You can see it in action here:

{% rune(footnote = "Use of the stringy_math! macro", options = "macros=true", experimental = true) %}
use std::experiments::stringy_math;

fn main() {
    let value = stringy_math!(add 10 sub 5);
    println(`result: {value}`);
}
{% end %}

## `const` evaluation

Work has been started to support *`const` evaluation*. This is a mode of execution
which can do work at compile time rather than runtime.

{% rune(footnote = "Asynchronous programming using select") %}
const VALUE = "Hello World";

fn main() {
	println(VALUE);
}
{% end %}

```rune
println("Hello World");
```
